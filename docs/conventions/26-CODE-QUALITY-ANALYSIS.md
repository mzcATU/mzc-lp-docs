# 26. 코드 품질 분석 (Code Quality Analysis)

> 정적 분석, 동적 분석, SonarQube 지표 가이드

---

## 언제 이 문서를 보는가?

| 상황 | 참조 섹션 |
|------|----------|
| SonarQube 지표 해석? | 섹션 2 |
| 리팩토링 기준? | 섹션 3 |
| AI 코드 검수 방법? | 섹션 4 |
| 정적/동적 분석 차이? | 섹션 1 |

---

## 1. 정적 분석 vs 동적 분석

### 1.1 개념 정의

| 분석 유형 | 정의 | 도구 | 확인 내용 |
|----------|------|------|----------|
| **정적 분석** | 코드 실행 없이 소스 분석 | SonarQube, ESLint, Checkstyle | 코딩 스타일, 복잡도, 중복, 보안 취약점 |
| **동적 분석** | 코드 실행하며 동작 확인 | JUnit, Jest, Integration Test | 비즈니스 로직 정확성, 경계값, 예외 처리 |

### 1.2 분석 단계

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           코드 품질 분석 파이프라인                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. 정적 분석 (Static Analysis)                                              │
│     ├── SonarQube: 전체 품질 대시보드                                         │
│     ├── ESLint/Checkstyle: 코딩 스타일                                        │
│     └── 목적: "코드가 표준과 규격을 준수하는가?"                                │
│                                                                              │
│  2. 동적 분석 (Dynamic Analysis)                                             │
│     ├── Unit Test: 개별 함수/메서드 검증                                      │
│     ├── Integration Test: 모듈 간 연동 검증                                   │
│     └── 목적: "코드가 비즈니스 로직을 올바르게 구현했는가?"                      │
│                                                                              │
│  [현실]                                                                       │
│  - 테스트 자동화는 생산성/효율성 문제로 현업에서 생략되기 쉬움                    │
│  - 그러나 AI 시대에는 테스트 코드 자동 생성이 가능하므로 생략 이유 없음           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. SonarQube 품질 지표

### 2.1 핵심 4대 지표

| 지표 | 정의 | 의미 | 기준 |
|------|------|------|------|
| **Maintainability** | 유지보수성 | 코드를 고치거나 확장하는 데 어려움 정도 | A~E 등급 |
| **Technical Debt** | 기술 부채 | 코드 품질 문제 해결에 필요한 예상 시간 | 시간(h/d) |
| **Duplication** | 코드 중복 | 복제된 코드 비율 | % |
| **Complexity** | 복잡도 | 순환 복잡도(Cyclomatic Complexity) | 숫자 |

### 2.2 지표 상세 해석

#### Maintainability (유지보수성)

```
정의: 코드를 고치거나 확장하는 데 어려움이 없는 정도

관련 요소:
├── Line of Code (코드 길이)
├── Technical Debt (기술 부채)
└── Code Smell (나쁜 냄새)

등급 기준:
A: 기술 부채 ≤ 5%
B: 기술 부채 ≤ 10%
C: 기술 부채 ≤ 20%
D: 기술 부채 ≤ 50%
E: 기술 부채 > 50%
```

#### Technical Debt (기술 부채)

```
정의: 코드 품질 문제를 해결하는 데 필요한 예상 작업 시간

해석:
├── 높은 기술 부채 → 향후 유지보수 비용 증가
├── 마이너 이슈라도 축적되면 큰 부채
└── 정기적 리팩토링으로 관리 필요

조언:
- 심각한 문제가 아닌 마이너 이슈라도 통찰(인사이트)을 얻어야 함
- 리팩토링, 모듈 분리 등 개선 방향 고려
```

#### Duplication (코드 중복)

```
정의: 복사-붙여넣기된 코드 비율

문제점:
├── 로직 변경 시 모든 중복 위치 수정 필요
├── 개발자의 인지적 부하(Cognitive Load) 증가
├── 버그 수정 누락 위험
└── 일관성 유지 어려움

판단 기준:
├── 중복 < 3%: 양호
├── 중복 3-5%: 주의
└── 중복 > 5%: 개선 필요

조언:
- 3줄 이상 중복 → 공통 함수 추출 고려
- 단, 과도한 추상화는 오히려 해로움
- "세 줄 중복 코드가 성급한 추상화보다 낫다"
```

#### Complexity (복잡도)

```
정의: 순환 복잡도(Cyclomatic Complexity) - 코드 분기 경로 수

계산: if, for, while, case, catch 등 분기문 개수 + 1

리팩토링 기준:
├── 1-10: 단순, 테스트 용이
├── 11-20: 보통
├── 21-25: 복잡, 리팩토링 권장
└── 25 이상: 매우 복잡, 리팩토링 필수

핵심 원칙:
"아무리 복잡한 비즈니스 로직이라도, 그것을 단순화하는 것이
소프트웨어 엔지니어의 핵심 역량이다"

"소프트웨어 공학은 인간을 편하게 하는 휴머니즘 학문이다.
사용하는 사람과 만드는 사람 모두를 행복하게 할 수 있어야
잘 만든 소프트웨어다."
```

---

## 3. 리팩토링 기준

### 3.1 파일 레벨

| 기준 | 임계값 | 조치 |
|------|--------|------|
| **파일 라인 수** | > 100줄 | 파일 분리 검토 |
| **파일 라인 수** | > 200줄 | 반드시 분리 |
| **클래스 메서드 수** | > 10개 | 책임 분리 검토 |
| **클래스 필드 수** | > 7개 | 값 객체 추출 검토 |

### 3.2 메서드 레벨

| 기준 | 임계값 | 조치 |
|------|--------|------|
| **메서드 라인 수** | > 20줄 | 메서드 추출 검토 |
| **메서드 파라미터** | > 4개 | 파라미터 객체 도입 |
| **순환 복잡도** | > 10 | 조건 분리/전략 패턴 |
| **순환 복잡도** | > 25 | 반드시 리팩토링 |

### 3.3 비즈니스 로직 vs 코드 변경

```
[중요 인사이트]

코드가 너무 과도하게 작성되거나 복잡도가 높아질 때에는,
개발팀이 비즈니스 로직 자체를 변경하는 것을 고민해야 할 수도 있다.

예시: 쿠팡의 비동기 결제 처리 방식 도입
- 시스템 요구사항이 비즈니스에 영향을 주어
- 비즈니스 로직 자체가 바뀌는 경우 발생

→ 때로는 시스템 프로세스 요구사항이 비즈니스를 바꿀 수 있다
```

---

## 4. AI 코드 검수 방법

### 4.1 3가지 검수 전략

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           AI 코드 검수 방법                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. AI 모델 간 교차 확인 (Cross Check)                                       │
│     ├── Claude, Codex, Gemini 등 다양한 AI 모델로 검토                        │
│     ├── 각 모델에게 코드 리뷰 요청                                            │
│     └── 서로 다른 관점에서 문제점 발견                                        │
│                                                                              │
│  2. SonarQube 정적 분석                                                       │
│     ├── 코드 스캔 실행                                                        │
│     ├── Bug, Vulnerability, Code Smell 확인                                  │
│     └── 품질 게이트 통과 여부 확인                                            │
│                                                                              │
│  3. AI에게 통합 테스트 코드 작성 지시                                          │
│     ├── "이 코드에 대한 Integration Test를 작성해줘"                          │
│     ├── 경계값, 예외 케이스 포함 요청                                          │
│     └── 테스트 통과 여부로 검증                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 AI 도구별 특성

| AI 도구 | 특성 | 적합한 용도 |
|---------|------|------------|
| **Claude Code** | 코드 작성 선호, 설계 지시에도 코드 생성 경향 | 구현 작업, 리팩토링 |
| **Codex** | 사용자 요구사항 이행, 필요한 코드만 작성 | 명확한 지시 기반 작업 |
| **Gemini** | 넓은 컨텍스트 이해 | 대규모 분석, 리뷰 |

```
조언:
- AI 도구 선택 시 각 도구의 장단점과 특성을 신중하게 고려
- Claude Code는 슬래시 커맨드(Slash Command)로 명확한 지시 필요
- 에이전틱 코드, 플러그인 등 생태계 활용
```

### 4.3 코드 리뷰 체크리스트

> 상세: [code-review-checklist.md](../templates/code-review-checklist.md)

```
AI 생성 코드 리뷰 시 추가 확인사항:

□ 비즈니스 로직이 요구사항과 일치하는가?
□ 트랜잭션 바운더리가 올바른가?
□ Edge Case 처리가 되어있는가?
□ 동시성 문제 (Race Condition) 고려되었는가?
□ 권한 검증이 포함되어 있는가?
□ 에러 핸들링이 적절한가?
□ 로그가 적절히 기록되는가?
```

---

## 5. 테스트 시나리오 도출

### 5.1 테스트 시나리오는 언제 만드는가?

```
테스트 시나리오는 요구사항 분석 및 설계 검토 단계에서 미리 도출되어야 한다.

┌─────────────────────────────────────────────────────────────────────────────┐
│  요구사항 분석 → 설계 검토 → 테스트 시나리오 도출 → 구현 → 테스트 실행       │
│                            ↑                                                │
│                     (TDD: 이 시점에서 테스트 코드 작성)                       │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 시나리오 도출 항목

| 항목 | 설명 | 예시 |
|------|------|------|
| **Happy Path** | 정상 흐름 | 수강 신청 → 성공 |
| **Edge Case** | 경계값 | 정원 100명일 때 100번째 신청 |
| **Error Case** | 예외 상황 | 정원 초과 시 신청 거부 |
| **Concurrent Case** | 동시성 | 동시 100명 신청 시 Race Condition |
| **Security Case** | 보안 | 권한 없는 사용자 접근 차단 |

---

## 6. TDD (Test-Driven Development)

### 6.1 TDD 핵심 개념

```
TDD의 본질:
"테스트 코드가 실제로 만들려는 코드의 동작 방식과 요구사항을 설명해 준다"

테스트 코드의 역할:
├── 단순한 확인용 코드가 아님
├── 작업 설계
├── 작업 계획
└── 우선순위가 '코드화된' 형태
```

### 6.2 TDD 워크플로우

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            TDD 사이클                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. RED: 실패하는 테스트 작성                                                │
│     └── 구현 전에 "무엇을 만들 것인가" 정의                                  │
│                                                                              │
│  2. GREEN: 테스트 통과하는 최소 코드 작성                                    │
│     └── 테스트만 통과하면 됨, 완벽할 필요 없음                               │
│                                                                              │
│  3. REFACTOR: 코드 개선                                                      │
│     └── 테스트 통과 상태 유지하며 리팩토링                                   │
│                                                                              │
│  → 반복                                                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.3 AI 시대의 TDD

```
AI에게 코드 생성 요청 시:

1. 먼저 테스트 코드 생성 요청
   "이 기능에 대한 테스트 코드를 먼저 작성해줘"

2. 테스트 코드 검토 후 구현 코드 요청
   "이 테스트를 통과하는 구현 코드를 작성해줘"

3. 장점:
   ├── 테스트 코드가 요구사항을 명확히 정의
   ├── 구현 코드 품질 향상
   └── 리그레션 방지
```

---

## 7. 로그 및 롤백 트랜잭션 분리

### 7.1 핵심 원칙

```
거래 정보의 중요성 때문에 모든 거래 정보는 로그로 남겨야 한다.
특히, 실패 로그는 장애 파악을 위해 훨씬 더 중요하다.
```

### 7.2 트랜잭션 분리

```java
// ❌ Bad: 로그와 비즈니스 로직이 같은 트랜잭션
@Transactional
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 이체 처리
    Account from = accountRepository.findById(fromId);
    Account to = accountRepository.findById(toId);
    from.withdraw(amount);
    to.deposit(amount);

    // 로그 기록 - 이체 실패 시 로그도 롤백됨!
    transactionLogRepository.save(new TransactionLog(...));
}

// ✅ Good: 로그 트랜잭션 분리
@Transactional
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    try {
        // 이체 처리
        Account from = accountRepository.findById(fromId);
        Account to = accountRepository.findById(toId);
        from.withdraw(amount);
        to.deposit(amount);

        // 성공 로그 (별도 트랜잭션)
        logService.logSuccess(fromId, toId, amount);
    } catch (Exception e) {
        // 실패 로그 (별도 트랜잭션) - 반드시 기록
        logService.logFailure(fromId, toId, amount, e);
        throw e;
    }
}

@Service
public class LogService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logSuccess(...) {
        // 별도 트랜잭션으로 실행 - 메인 트랜잭션 롤백되어도 유지
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logFailure(...) {
        // 별도 트랜잭션으로 실행 - 반드시 기록됨
    }
}
```

### 7.3 결정 주체

```
로그 트랜잭션 분리 여부는 업무 담당자(기획자/PO)가 결정해야 한다.

질문 예시:
- "이체 실패 시 로그가 남아야 하나요?"
- "로그 기록 실패 시 메인 작업도 롤백해야 하나요?"

→ 이는 기술적 문제가 아니라 비즈니스 결정
```

---

## 8. 체크리스트

### 정적 분석 확인 항목

- [ ] SonarQube 분석 실행
- [ ] Bug: 0개
- [ ] Vulnerability: 0개
- [ ] Code Smell: 검토 완료
- [ ] 순환 복잡도 < 25
- [ ] 파일 라인 < 200
- [ ] 중복률 < 5%

### 동적 분석 확인 항목

- [ ] Unit Test 통과
- [ ] Integration Test 통과
- [ ] Edge Case 테스트
- [ ] 동시성 테스트 (해당 시)
- [ ] 테스트 커버리지 확인

---

## 9. 관련 문서

| 문서 | 내용 |
|------|------|
| [15-BACKEND-TEST-CONVENTIONS](./15-BACKEND-TEST-CONVENTIONS.md) | 백엔드 테스트 컨벤션 |
| [16-FRONTEND-TEST-CONVENTIONS](./16-FRONTEND-TEST-CONVENTIONS.md) | 프론트엔드 테스트 컨벤션 |
| [code-review-checklist](../templates/code-review-checklist.md) | 코드 리뷰 체크리스트 |
| [transaction-boundaries](../context/transaction-boundaries.md) | 트랜잭션 바운더리 |
